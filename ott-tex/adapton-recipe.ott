embed {{ tex-preamble
\usepackage{charter}
%\usepackage{euler}
\usepackage{inconsolata}
\usepackage{mathabx} % for otriangleup
\usepackage{MnSymbol} % for cupdot
\usepackage{xcolor}
\usepackage{makecell}
}}

metavar x , y , z ::=
{{ coq nat}} {{ coq-equality }}

grammar

terminals :: 'terminals_' ::=
| |-> :: :: mapsto {{ tex \mapsto }}
| |/-> :: :: notmapsto {{ tex \not\mapsto }}
| \ :: :: lambda {{ tex \lambda }}
| !! :: :: downarrow {{ tex \Downarrow }}
| |- :: :: vdash {{ tex \vdash }}
| != :: :: noteq {{ tex  \neq }}

% | == :: :: equiv {{ tex \equiv }}
% | forall :: :: forall {{ tex \forall }}
% | exists :: :: exists {{ tex \exists }}
% | %% :: :: apart {{ tex \otriangleup }}
% | -> :: :: rightarrow {{ tex \texttt{->} }}
% | => :: :: thickrightarrow {{ tex \texttt{=>} }}
% | := :: :: defineOrAssign {{ tex \mathrel{\texttt:\texttt=} }}
% | * :: :: cdot {{ tex \texttt{*} }}
% | ^* :: :: stepStar {{ tex \texttt{\^{}*} }}
% | +* :: :: plusStar {{ tex \texttt{+*} }}
% | & :: :: amp {{ tex \texttt{\&} }}
% | ! :: :: bang {{ tex \texttt{!} }}
% | @ :: :: at {{ tex \texttt{@} }}
% | >> :: :: mapOp {{ tex \texttt{>>} }}
% | % :: :: projectOp {{ tex \texttt{\%} }}
% | ~ :: :: tilde {{ tex \texttt{\textasciitilde} }} {{ com Text ascii tilde. }}
% | ;; :: :: dsemi {{ tex {~|~} }}
% | ~> :: :: leadsto {{ tex \leadsto }}
% | --> :: :: lra {{ tex \longrightarrow }}
% | #elipses :: :: eplises {{ tex \cdots }}
% | #empty :: :: empty {{ tex \epsilon }}

formula :: 'formula_' ::=
 | judgement :: :: judgement
 | Store ( pp ) =  cell :: :: graphGetCell
 | v1 = v2 :: :: equal
 | v1 /= v2 :: :: notEqual
 | Space1 = Space2 :: :: spaceEqual
 | Moment1 = Moment2 :: :: momentEqual
 | Moment1 != Moment2 :: :: momentNotEqual
 | pp1 = pp2 :: :: fullPointerEqual
 | pp \notin Path :: :: pointerNotInPath {{ tex [[pp]] \not\in [[Path]] }}
 | formula1 \/ formula2 :: :: and {{ tex [[formula1]] \bigvee [[formula2]] }}
 | ( formula ) :: :: formula {{ tex \left([[formula]]\right) }}

s :: 's_' ::= {{ com Symbols. }}
 | literal :: :: literal {{ tex \cdots }} {{ com Literal number, or symbol. }}
 | s1 - s2 :: :: dash {{ com Dash binary from. }}
 | s1 . s2 :: :: dot {{ com Dot binary. }}
 | s1 ( s2 ) :: :: app {{ com App binary form. }}

cell {{ tex c }} :: 'cell_' ::= {{ com Cells. }}
 | NonThunk v :: :: NonThunk {{ com Non-thunk. }} {{ tex [[v]] }}
 | Thunk ( e , StoreValueOption ) :: :: Thunk {{ com Thunk. }} {{ tex \left<[[e]], [[StoreValueOption]]\right> }}

Store {{ tex \sigma }} :: 'Store_' ::= {{ com Stores. }}
 | empty :: :: empty {{ com Empty. }} {{ tex \cdot }}
 | pp |-> cell :: :: cell {{ com Cell. }}
 | Store1 , Store2 :: :: union {{ com Disjoint union. }} {{ tex [[Store1]] \cupdot [[Store2]] }}
 | Store { pp |-> cell } :: M :: updateCell {{ com Cell update. }}
 | Store { pp |-> v } :: M :: updateValue {{ com Defined as two cases, on $[[v]]$. }}
 | Store { pp |/-> } :: M :: removePointer {{ com Remove cell at pointer $[[pp]]$. }}

StoreValueOption {{ tex \tilde{v} }} :: 'StoreValueOption_' ::= {{ com Optional thunk cache (store and value). }}
 | empty :: :: empty {{ tex \bullet }} {{ com None. }}
 | ( Store , v ) :: :: value {{ com Some store~$[[Store]]$ and value~$[[v]]$. }} {{ tex \left<[[Store]], [[v]]\right> }}

p :: 'p_' ::= {{ com Pointers (spatial component only). }}
 | Space :: :: pointer {{ com Space $[[Space]]$. }}

pp {{ tex \tilde{p} }}, qq {{ tex \tilde{q} }} :: 'pp_' ::= {{ com Full pointers. }}
 | ( Space , Moment ) ^ d :: :: pointer {{ tex \left<[[Space]],[[Moment]]\right>^{[[d]]} }} {{ com Space $[[Space]]$ and moment $[[Moment]]$, dimension order~$[[d]]$. }}

d :: 'd_' ::= {{ com Dimension order. }}
 | st :: :: st {{ com Space, time. }}
 | ts :: :: ts {{ com Time, space. }}

Space {{ tex \varsigma }} :: 'Space_' ::= {{ com Spaces. }}
 | here :: :: here {{ com Here. }}
 | here ( s ) :: :: fractal {{ com Fractal aspect of Here. }}
 | subSpace ( Space , s ) :: M :: subSpace  {{ tex [[Space]]([[s]]) }} {{ com Subspace $[[s]]$ of space $[[Space]]$. }}

Moment {{ tex \psi }} :: 'Moment_' ::= {{ com Moments. }}
 | now :: :: now {{ com Now. }}
 | now ( s ) :: :: fractal {{ com Fractal aspect of Now. }}
 | subMoment ( Moment , s ) :: M :: subMoment {{ tex [[Moment]]([[s]]) }} {{ com Submoment $[[s]]$ of moment $[[Moment]]$. }}

v :: 'v_' ::= {{ com Values. }}
 | \ x . e :: :: lambda {{ com Lambda. }}
 | x :: :: var {{ com Variable. }}
 | thunk ( e ) :: :: thunk {{ com Thunk. }}
 | sym s :: :: symbol {{ com Symbol. }}
 | ptr p :: :: pointer {{ com Pointer. }}
 | sp Space :: :: space {{ com Space. }}
 | mt Moment :: :: moment {{ com Moment. }}

e :: 'e_' ::= {{ com Expressions. }}
 | here ( ) :: :: here {{ com Here. }}
 | now ( ) :: :: now {{ com Now. }}
 | thunk ( e ) :: :: thunk {{ com Thunk. }}
 | do C ( e1 ) { e2 } :: :: do {{ com Do. }}
 | put ( e1 , e2 , e3 ) :: :: putThree {{ com Put (fully-qualified). }}
 | put ( e1 , e2 ) :: :: putTwo {{ com Put (into current moment). }}
 | get ( e ) :: :: get {{ com Get. }}
 | force ( e ) :: :: force {{ com Force. }}

 | let x = e1 in e2 :: :: let {{ com Let sequencing. }}
 | let x = e1 in :: M :: letHead
 | e1 ( e2 ) :: :: apply {{ com Application. }}
 | e1 - e2 :: :: symbolDash {{ com Minus binop. }}
 | e1 . e2 :: :: symbolDot {{ com Dot binop. }}
 | [ v / x ] e :: M :: subst {{ com Substituion. }}
 | v :: :: value {{ com Value. }}
 | ( e ) :: M :: paren {{ com Paren. }}


C :: 'C_' ::= {{ com Do context. }}
 | CxtVerb CxtDim :: :: context {{ com Verb and dimension. }}

CxtVerb :: 'ContextVerb_' ::= {{ com Context verb. }}
 | within :: :: within {{ com Within. }}
 | goto :: :: goto {{ com Goto. }}

CxtDim :: 'ContextDim_' ::= {{ com Context dimension. }}
 | space :: :: space {{ com Space dimension. }}
 | moment :: :: moment {{ com Time dimension. }}


Path {{ tex \pi }} :: 'Path_' ::= {{ com Paths. }}
 | empty :: :: empty {{ tex \cdot }} {{ com Empty (no evaluating thunk pointers). }}
 | Path , pp :: :: pointer {{ com Thunk pointer~$[[pp]]$ evaluating at~$[[Path]]$. }}


%----------------------------

Inc :: '' ::= {{ com \textbf{Incremental Graph Semantics} (below) }}
|  :: :: 'Inc' {{ tex --- }}

%----------------------------

m :: 'm_' ::= {{ com Meta-moments, as tagged natural numbers. }}
n :: 'n_' ::= {{ com Edge identifers, as tagged natural numbers. }}

ppp {{ tex \dot{\tilde{p} } }} , qqq {{ tex \dot{\tilde{q} } }} :: 'ppp_' ::= {{ com Graph-node pointers. }}
 | ( pp , m ) :: :: pointer {{ com Full pointer~$[[pp]]$ at meta-moment~$[[m]]$ }}

t :: 't_' ::= {{ com Local traces. A list of edge identifiers. }}
 | empty :: :: empty {{ com Empty. }} {{ tex \cdot }}
 | t1 , t2 :: :: sequence {{ com Sequence. }}
 | n :: :: edge {{ com Edge (identified as $[[n]]$) }}

Graph {{ tex G }} :: 'Graph_' ::= {{ com Graphs. }}
 | empty :: :: empty {{ com Empty. }} {{ tex \cdot }}
 | Graph1 , Graph2 :: :: union {{ com Disjoint union. }} {{ tex [[Graph1]] \cupdot [[Graph2]] }}
 | ppp |-> node :: :: node {{ com Graph node (cell). }}
 | n |-> edge :: :: edge {{ com Graph edge. }}

node :: 'node_' ::= {{ com Nodes (graph cells). }}
 | NonThunk v :: :: NonThunk {{ com Non-thunk. }} {{ tex [[v]] }}
 | Thunk ( e , cache ) :: :: Thunk {{ com Thunk. }} {{ tex \left<[[e]], [[cache]]\right> }}

cache {{ tex \dot{\tilde{v} } }} :: 'cache_' ::= {{ com Thunk node's cache. }}
 | empty :: :: empty {{ com Empty. }} {{ tex \bullet }}
 | ( t , v ) :: :: full {{ com Filled. }} {{ tex \left<[[t]], [[v]]\right> }}

edge :: 'edge_' ::= {{ com Edges. }}
 | ppp -- A -- b --> qq :: :: edge {{ tex [[ppp]] \longrightarrow^{[[A]]}_{[[b]]} [[qq]] }}

A :: 'A_' ::= {{ com Actions (and relevant values). }}
 | put ( v ) :: :: put {{ com Put value~$[[v]]$. }}
 | get ( v ) :: :: get {{ com Get value~$[[v]]$. }}
 | force ( v ) :: :: force {{ com Force edge target, resulting in~$[[v]]$. }}

b :: 'b_' ::= {{ com Status bit. }}
 | clean :: :: clean {{ com Clean. }}
 | dirty :: :: dirty {{ com Dirty. }}

defns Ref :: '' ::=

defn
Store1 ; Path ; Moment ; Space |- e !! Store2 ; v
:: :: eval :: 'E_'
{{ tex [[Store1]] ; [[Path]] \vdash^{[[Space]]}_{[[Moment]]} [[e]] \Downarrow [[Store2]] ; [[v]] }}
by

----------------------------------------------------------------------------------------- :: here
Store ; Path ; Moment ; Space |- here() !! Store ; sp Space

----------------------------------------------------------------------------------------- :: now
Store ; Path ; Moment ; Space |- now() !! Store ; mt Moment


----------------------------------------------------------------------------------------- :: thunk
Store ; Path ; Moment ; Space |- thunk(e) !! Store ; thunk(do goto space(sp Space){ e })

Store1 ; Path ; Moment ; Space |- e1 !! Store2 ; thunk(e2)
Store2 ; Path ; Moment ; Space |- e2 !! Store3 ; v
------------------------------------------------------------ :: forceThunk
Store1 ; Path ; Moment ; Space |- force(e1) !! Store3 ; v



------------------------------------------------------- :: sym
Store ; Path ; Moment ; Space |- sym s !! Store ; sym s


Store1 ; Path ; Moment ; Space |- e1 !! Store2 ; sym s
Store2 ; Path ; Moment ; subSpace(Space, s) |- e2 !! Store3 ; v
--------------------------------------------------------------------------- :: withinSpace
Store1 ; Path ; Moment ; Space |- do within space(e1) { e2 } !! Store3 ; v

Store1 ; Path ; Moment ; Space1 |- e1 !! Store2 ; sp Space2
Store2 ; Path ; Moment ; Space2 |- e2 !! Store3 ; v
--------------------------------------------------------------------------- :: gotoSpace
Store1 ; Path ; Moment ; Space1 |- do goto space(e1) { e2 } !! Store3 ; v

Store1 ; Path ; Moment ; Space |- e1 !! Store2 ; sym s
Store2 |- undelay(Store2, subMoment(Moment, s)) !! Store3
Store3 ; Path ; subMoment(Moment, s) ; Space |- e2 !! Store4 ; v
--------------------------------------------------------------------------- :: withinMoment
Store1 ; Path ; Moment ; Space |- do within moment(e1) { e2 } !! Store4 ; v

Store1 ; Path ; Moment1 ; Space |- e1 !! Store2 ; mt Moment2
Store2 |- undelay(Store2, Moment2) !! Store3
Store3 ; Path ; Moment2 ; Space |- e2 !! Store4 ; v
--------------------------------------------------------------------------- :: gotoMoment
Store1 ; Path ; Moment ; Space |- do goto moment(e1) { e2 } !! Store4 ; v


Store1 ; Path ; Moment ; Space |- e1 !! Store2 ; sym s
Store2 ; Path ; Moment ; Space |- e2 !! Store3 ; v
(subSpace(Space, s), Moment)^st \notin Path
---------------------------------------------------------------------------------------------------------------- :: putNow
Store1 ; Path ; Moment ; Space |- put (e1, e2) !! Store3{ (subSpace(Space, s), Moment)^st |-> v } ; ptr subSpace(Space,s)


Store1 ; Path ; Moment1 ; Space |- e1 !! Store2 ; sym s
Store2 ; Path ; Moment1 ; Space |- e2 !! Store3 ; v
Store3 ; Path ; Moment1 ; Space |- e2 !! Store4 ; mt Moment2
--------------------------------------------------------------------------------------------------------------- :: putDelay
Store ; Path ; Moment1 ; Space |- put (e1, e2) !! Store4{ (subSpace(Space, s), Moment2)^ts |-> v } ; ptr subSpace(Space,s)


Store1 ; Path ; Moment ; Space1 |- e !! Store2 ; ptr Space2
Store2((Space2, Moment)^st) = NonThunk v
-------------------------------------------------------------------- :: getNonThunk
Store1 ; Path ; Moment ; Space1 |- get(e) !! Store2 ; v

Store1 ; Path ; Moment ; Space1 |- e !! Store2 ; ptr Space2
Store2((Space2, Moment)^st) = Thunk(e0, StoreValueOption)
--------------------------------------------------------------- :: getThunk
Store1 ; Path ; Moment ; Space1 |- get(e) !! Store2 ; thunk(e0)



Store1 ; Path ; Moment ; Space1 |- e !! Store2 ; ptr Space0
Store2((Space0, Moment)^st) = Thunk(e0, empty)
Store2 ; Path, (Space0, Moment)^st ; Moment ; Space1 |- e0 !! Store3 ; v
----------------------------------------------------------------------------------------- :: forceEmpty
Store1 ; Path ; Moment ; Space1 |- force(e) !! Store3{ (Space0, Moment)^st |-> Thunk(e0, (Store2, v)) } ; v

Store1 ; Path ; Moment ; Space1 |- e !! Store2 ; ptr Space0
Store2((Space0, Moment)^st) = Thunk(e0, (Store0, v))
Store0 <= Store2
--------------------------------------------------------- :: forceHit
Store1 ; Path ; Moment ; Space1 |- force(e) !! Store2 ; v

Store1 ; Path ; Moment ; Space |- e !! Store2 ; ptr Space0
Store2((Space0, Moment)^st) = Thunk(e0, (Store0, v0))
Store0 </= Store2
Store2 ; Path, (Space0, Moment)^st ; Moment ; Space |- e0 !! Store3 ; v
---------------------------------------------------------------------------------------- :: forceMiss
Store1 ; Path ; Moment ; Space |- force(e) !! Store3{ (Space0, Moment)^st |-> Thunk(e0, (Store2, v)) } ; v


defn
Store1 |- undelay ( Store2 , Moment ) !! Store3
:: :: undelay :: 'undelay_'
by


----------------------------------- :: empty
Store |- undelay (empty, Moment) !! Store


Store |- undelay (Store1, Moment) !! Store'
Store' |- undelay (Store2, Moment) !! Store''
--------------------------------------------- :: binary
Store |- undelay (Store1, Store2, Moment) !! Store''

----------------------------------------------------------------------------------------------------- :: moment
Store |- undelay( (Space, Moment)^ts |-> cell, Moment ) !! Store{ (Space, Moment)^ts |/-> }{(Space, Moment)^st |-> cell }

Moment1 != Moment2
----------------------------------------------------------------------------------------------------- :: skipMoment
Store |- undelay( (Space, Moment1)^ts |-> cell, Moment2 ) !! Store

----------------------------------------------------------------------------------------------------- :: skipSpace
Store |- undelay( (Space, Moment1)^st |-> cell, Moment2 ) !! Store

defn
Store1 </= Store2
:: :: notAligned :: 'NA_'
{{ tex [[Store1]] \not\leq [[Store2]] }}
by

defn
Store1 <= Store2
:: :: aligned :: 'A_'
{{ tex [[Store1]] \leq [[Store2]] }}
by


---------------- :: empty
empty <= Store


Store1 <= Store3
Store2 <= Store4
----------------------------------- :: binary
Store1 , Store2 <= Store3 , Store4


-------------------------- :: cell
pp |-> cell <= pp |-> cell

---------------------------------------------------- :: cache
pp |-> Thunk(e,empty) <= pp |-> Thunk(e,(Store,v))
