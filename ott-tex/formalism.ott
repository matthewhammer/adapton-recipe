embed {{ tex-preamble
\usepackage{charter}
\usepackage{euler}
\usepackage{inconsolata}
\usepackage{mathabx} % for otriangleup
}}

metavar x , y , z ::=
{{ coq nat}} {{ coq-equality }}

grammar

formula :: 'formula_' ::=
 | judgement :: :: judgement
 | G ( s ) =  n :: :: graphGetNode

v :: 'v_' ::= {{ com Values. }}
 | #elipses :: M :: dots {{ com Most existing (e.g., Motoko) forms. }}
 | \ x . e :: :: lambda
 | e1 - e2 :: :: symbolDash
 | e1 . e2 :: :: symbolDot
 | x :: :: var
 | thunk { e } :: :: thunk
 | sym s :: :: symbol
 | addr s :: :: address

e :: 'e_' ::= {{ com Expressions. }}
 | #elipses :: M :: dots {{ com Existing (e.g., Motoko) forms. }}
 | e1 ( e2 ) :: :: apply
 | e1 := e2 :: :: put
 | @ e1 :: :: get
 | force e :: :: force
 | return v :: :: return
 | let x = e1 in e2 :: :: let
 | do @ e1 with e2 { e3 } :: :: doAt
 | [ v / x ] e :: M :: subst
 | v :: M :: value

t :: 'trace_' ::= {{ com Traces. }}
 | return v :: :: value {{ com Return value $[[v]]$. }}
 | t1 ; t2 :: :: seq {{ com Sequence subtraces $[[t1]]$ and $[[t2]]$. }}
 | #empty :: :: empty {{ com Identity trace for sequencing via \texttt{;}. }}
 | s := v :: :: put {{ com Put into $[[s]]$ value $[[v]]$. }}
 | @ s = v :: :: get {{ com Get from $[[s]]$ equals value $[[v]]$. }}
 | h { t } :: S :: nest {{ com Nested subtrace, with head $[[h]]$. }}

h :: 'head_' ::= {{ com Trace heads. }}
 | do @ s with e :: :: doAtWith
 | do @ s :: :: doAt
 | with e :: :: with

G :: 'graph_' ::= {{ com Graphs. }}
 | #empty :: :: empty {{ com Empty graph. }}
 | s : n :: :: node {{ com Graph node. }}
 | force s1 v s2  :: :: force {{ com Force edge. }} {{ tex [[s1]] \rightarrow^\texttt{force}_[[v]] [[s2]] }}
 | get s1 v s2 :: :: get {{ com Get edge. }} {{ tex [[s1]] \rightarrow^\texttt{get}_[[v]] [[s2]] }}
 | put s1 v s2 :: :: put {{ com Put edge. }} {{ tex [[s1]] \rightarrow^\texttt{put}_[[v]] [[s2]] }}
 | G1 , G2 :: :: union {{ com Graph union (disjoint). }}

n :: 'node_' ::= {{ com Nodes. }}
 | ( e , - , - ) :: :: thunkUneval {{ com Thunk, unevaluated. }}
 | ( e , v , t ) :: :: thunkEvaled {{ com Thunk, evaluated. }}
 | v :: :: refCell {{ com Reference cell. }}

s :: 'sym_' ::= {{ com Atomic symbols. }}


terminals :: 'terminals_' ::=
| == :: :: equiv {{ tex \equiv }}
| forall :: :: forall {{ tex \forall }}
| exists :: :: exists {{ tex \exists }}
| %% :: :: apart {{ tex \otriangleup }}
| \ :: :: lambda {{ tex \lambda }}
| -> :: :: rightarrow {{ tex \texttt{->} }}
| => :: :: thickrightarrow {{ tex \texttt{=>} }}
| := :: :: defineOrAssign {{ tex \mathrel{\texttt:\texttt=} }}
| * :: :: cdot {{ tex \texttt{*} }}
| ^* :: :: stepStar {{ tex \texttt{\^{}*} }}
| +* :: :: plusStar {{ tex \texttt{+*} }}
| & :: :: amp {{ tex \texttt{\&} }}
| $ :: :: dollar {{ tex \texttt{\$} }}
| ! :: :: bang {{ tex \texttt{!} }}
| @ :: :: at {{ tex \texttt{@} }}
| >> :: :: mapOp {{ tex \texttt{>>} }}
| % :: :: projectOp {{ tex \texttt{\%} }}
| ~ :: :: tilde {{ tex \texttt{\textasciitilde} }} {{ com Text ascii tilde. }}
| |- :: :: vdash {{ tex \vdash }}
| ;; :: :: dsemi {{ tex {~|~} }}
| ~> :: :: leadsto {{ tex \leadsto }}
| --> :: :: lra {{ tex \longrightarrow }}
| !! :: :: downarrow {{ tex \Downarrow }}
| #elipses :: :: eplises {{ tex \cdots }}
| #empty :: :: empty {{ tex \epsilon }}



defns J :: '' ::=

defn
G |- s clean :: :: clean :: 'clean_'
{{ com Clean node. }}
by

defn
e !! v :: :: pureEval :: 'pureEval_'
{{ com Pure evaluation. }}
by


defn
G1 ; s ; e0 |- e !! G2 ; v ; t ::  :: eval :: 'eval_'
{{ com Evaluation. }}
by

G1 ; s ; e0 |- e1 !! G2 ; sym s1 ; t1
e0 ( sym s1 ) !! sym s2
G2 ; s ; e0 |- e2 !! G3 ; v ; t2
----------------------------------------------------- :: put
G1 ; s ; e0 |- @ e1 := e2 !! G3 ; addr s2 ; t1 ; t2

G1 ; s ; e0 |- e !! G2 ; thunk { e1 } ; t1
G2 ; s ; e0 |- e1 !! G3 ; v ; t2
----------------------------------------------- :: forcePure
G1 ; s ; e0 |- force e !! G2 ; v ; t1 ; t2

G1 ; s ; e0 |- e !! G2 ; addr s1 ; t1
G2(s1) = (e1, v, t2)
G2 |- s1 clean
----------------------------------------------- :: forceClean
G1 ; s ; e0 |- force e !! G2 ; v ; t1 ; t2

G1 ; s ; e0 |- e !! G2 ; addr s1 ; t1
G1(s1) = (e1, -, -)
G2 ; s ; e0 |- e1 !! G3 ; v ; t2
----------------------------------------------- :: forceEval
G1 ; s ; e0 |- force e !! G3, s : (e1, v, t2) ; v ; t1  ; t2

