embed {{ tex-preamble
\usepackage{charter}
\usepackage{euler}
\usepackage{inconsolata}
\usepackage{mathabx} % for otriangleup
}}

metavar x , y , z ::=
{{ coq nat}} {{ coq-equality }}

grammar

formula :: 'formula_' ::=
 | judgement :: :: judgement
 | G ( s ) =  n :: :: graphGetNode

v :: 'v_' ::= {{ com Values. }}
 | \ x . e :: :: lambda {{ com Lambda. }}
 | x :: :: var {{ com Variable. }}
 | #elipses :: :: dots {{ com Other existing forms. }}
 | thunk { e } :: :: thunk {{ com Thunk. }}
 | sym s :: :: symbol {{ com Symbol. }}
 | addr s :: :: address {{ com Address. }}

e :: 'e_' ::= {{ com Expressions. }}
 | let x = e1 in e2 :: :: let {{ com Let sequencing. }}
 | e1 ( e2 ) :: :: apply {{ com Application. }}
 | e1 - e2 :: :: symbolDash {{ com Minus binop. }}
 | e1 . e2 :: :: symbolDot {{ com Dot binop. }}
 | [ v / x ] e :: M :: subst {{ com Substituion. }}
 | v :: :: value {{ com Value. }}
 | #elipses ::  :: dots {{ com Other existing forms. }}
 | @ e1 := e2 :: :: put {{ com Put value at symbol. }}
 | @ e1 :: :: get {{ com Get value at symbol. }}
 | force e :: :: force {{ com Force a thunk, or thunk address. }}
 | h { e3 } :: :: nest {{ com Nested subcomputation. }}

h :: 'head_' ::= {{ com Nested expression heads. }}
 | do @ e1 with e2 :: :: doAtWith
 | do @ e :: :: doAt
 | with e :: :: with

t :: 'trace_' ::= {{ com Traces. }}
 | v :: :: value {{ com Final value $[[v]]$. }}
 | t1 ; t2 :: :: seq {{ com Sequence subtraces $[[t1]]$ and $[[t2]]$. }}
 | #empty :: :: empty {{ com Identity trace for sequencing via \texttt{;}. }}
 | s := v :: :: put {{ com Put into $[[s]]$ value $[[v]]$. }}
 | @ s = v :: :: get {{ com Get from $[[s]]$ equals value $[[v]]$. }}
 | H { t } :: :: nest {{ com Nested subtrace, with head $[[H]]$. }}

H :: 'traceHead_' ::= {{ com Nested trace heads. }}
 | do @ s with e :: :: doAtWith
 | do @ s :: :: doAt
 | with e :: :: with

G :: 'graph_' ::= {{ com Graphs. }}
 | #empty :: :: empty {{ com Empty graph. }}
 | s : n :: :: node {{ com Graph node. }}
 | a :: :: arrow {{ com Graph edge (``arrow''). }}
 | G1 , G2 :: :: union {{ com Graph union (disjoint). }}

a :: 'edge_' ::= {{ com Graph edges (``Arrows''). }}
 | s1 A v b s2 :: :: arrow {{ com Source $[[s1]]$, action $[[A]]$, value $[[v]]$, dirty bit $[[b]]$ and target $[[s2]]$. }}
                           {{ tex [[s1]] \rightarrow^[[A]]_{([[v]], [[b]])} [[s2]] }}

A :: 'action_' ::= {{ com Actions (``Arrow heads''). }}
 | force  :: :: force {{ com Force action. }}
 | get :: :: get {{ com Get action. }}
 | put :: :: put {{ com Put action. }}

b :: 'dirtyBit_' ::= {{ com Dirty bit. }}
 | clean :: :: clean {{ com Clean. }}
 | dirty :: :: dirty {{ com Dirty. }}

n :: 'node_' ::= {{ com Nodes. }}
 | ( e , - , - ) :: :: thunkUneval {{ com Thunk, unevaluated. }}
 | ( e , v , t ) :: :: thunkEvaled {{ com Thunk, evaluated. }}
 | v :: :: refCell {{ com Reference cell. }}

s :: 'sym_' ::= {{ com Atomic symbols. }}


terminals :: 'terminals_' ::=
| == :: :: equiv {{ tex \equiv }}
| forall :: :: forall {{ tex \forall }}
| exists :: :: exists {{ tex \exists }}
| %% :: :: apart {{ tex \otriangleup }}
| \ :: :: lambda {{ tex \lambda }}
| -> :: :: rightarrow {{ tex \texttt{->} }}
| => :: :: thickrightarrow {{ tex \texttt{=>} }}
| := :: :: defineOrAssign {{ tex \mathrel{\texttt:\texttt=} }}
| * :: :: cdot {{ tex \texttt{*} }}
| ^* :: :: stepStar {{ tex \texttt{\^{}*} }}
| +* :: :: plusStar {{ tex \texttt{+*} }}
| & :: :: amp {{ tex \texttt{\&} }}
| $ :: :: dollar {{ tex \texttt{\$} }}
| ! :: :: bang {{ tex \texttt{!} }}
| @ :: :: at {{ tex \texttt{@} }}
| >> :: :: mapOp {{ tex \texttt{>>} }}
| % :: :: projectOp {{ tex \texttt{\%} }}
| ~ :: :: tilde {{ tex \texttt{\textasciitilde} }} {{ com Text ascii tilde. }}
| |- :: :: vdash {{ tex \vdash }}
| ;; :: :: dsemi {{ tex {~|~} }}
| ~> :: :: leadsto {{ tex \leadsto }}
| --> :: :: lra {{ tex \longrightarrow }}
| !! :: :: downarrow {{ tex \Downarrow }}
| #elipses :: :: eplises {{ tex \cdots }}
| #empty :: :: empty {{ tex \epsilon }}



defns J :: '' ::=

defn
G |- s clean :: :: clean :: 'clean_'
{{ com Clean node. }}
by

defn
e !! v :: :: pureEval :: 'pureEval_'
{{ com Pure evaluation. }}
by


defn
G1 ; s ; e0 |- e !! G2 ; v ; t ::  :: eval :: 'eval_'
{{ com Evaluation. }}
by

G1 ; s ; e0 |- e1 !! G2 ; sym s1 ; t1
e0 ( sym s1 ) !! sym s2
G2 ; s ; e0 |- e2 !! G3 ; v ; t2
-------------------------------------------------------------- :: put
G1 ; s ; e0 |- @ e1 := e2 !! G3, s put v clean s2 ; addr s2 ; t1 ; t2

G1 ; s ; e0 |- e !! G2 ; thunk { e1 } ; t1
G2 ; s ; e0 |- e1 !! G3 ; v ; t2
----------------------------------------------- :: forcePure
G1 ; s ; e0 |- force e !! G2 ; v ; t1 ; t2

G1 ; s ; e0 |- e !! G2 ; addr s1 ; t1
G2(s1) = (e1, v, t2)
G2 |- s1 clean
------------------------------------------------------- :: forceClean
G1 ; s ; e0 |- force e !! G2, s force v clean s1 ; v ; t1 ; t2

G1 ; s ; e0 |- e !! G2 ; addr s1 ; t1
G1(s1) = (e1, -, -)
G2 ; s ; e0 |- e1 !! G3 ; v ; t2
---------------------------------------------------------------------------- :: forceEval
G1 ; s ; e0 |- force e !! G3, s1 : (e1, v, t2), s force v clean s1 ; v ; t1  ; t2

