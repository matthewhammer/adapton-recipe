embed {{ tex-preamble
\usepackage{charter}
\usepackage{euler}
\usepackage{inconsolata}
\usepackage{mathabx} % for otriangleup
\usepackage{xcolor}
\usepackage{makecell}
}}

metavar x , y , z ::=
{{ coq nat}} {{ coq-equality }}

grammar

formula :: 'formula_' ::=
 | judgement :: :: judgement
 | G ( p ) =  NodeData :: :: graphGetNodeData
 | G ( p ) =  EdgeData :: :: graphGetEdgeData
 | v1 = v2 :: :: equal
 | v1 /= v2 :: :: notEqual
 | G1 = G2 :: :: graphEqual
 | \\ :: :: newLine {{ tex \\ }}

v :: 'v_' ::= {{ com Values. }}
 | \ x . e :: :: lambda {{ com Lambda. }}
 | x :: :: var {{ com Variable. }}
 | #elipses :: :: dots {{ com \makecell{$\vdots$\\\emph{Other existing forms}.\\$\vdots$\\} }}
 | thunk { e } :: :: thunk {{ com Thunk. }}
 | sym s :: :: symbol {{ com Symbol. }}
 | ptr p :: :: address {{ com Pointer. }}

e, path {{ tex \pi }} :: 'e_' ::= {{ com \makecell[l]{Expressions~\hspace{1in}\\(We reserve $\pi$ for pure functions from symbol to symbol.\\We call these functions \emph{paths}.)} }}
 | let x = e1 in e2 :: :: let {{ com Let sequencing. }}
 | let x = e1 in :: M :: letHead
 | e1 ( e2 ) :: :: apply {{ com Application. }}
 | e1 - e2 :: :: symbolDash {{ com Minus binop. }}
 | e1 . e2 :: :: symbolDot {{ com Dot binop. }}
 | [ v / x ] e :: M :: subst {{ com Substituion. }}
 | v :: :: value {{ com Value. }}
 | #elipses ::  :: dots {{ com \makecell{$\vdots$\\\emph{Other existing forms}.\\$\vdots$\\} }}
 | @ e1 := e2 :: :: put {{ com \textbf{Put} value of $[[e2]]$ at symbol $[[e1]]$. }}
 | @ e :: :: get {{ com \textbf{Get} value at pointer $[[e]]$. }}
 | force e :: :: force {{ com \textbf{Force} a thunk (pure value), or thunk pointer. }}
 | h { e3 } :: :: nest {{ com \textbf{Nest}ed subcomputation. }}
 | ( e ) :: M :: paren {{ com Paren. }}

h :: 'head_' ::= {{ com Nested expression heads (assume body $[[e2]]$). }}
 | with path :: :: with {{ com Extend the written symbols' pointers with path $[[path]]$. }}
 | do @ e1 :: :: doAt {{ com  Macro for common idiom (put thunk and force it immediately). }}
 | do @ e1 with path :: :: doAtWith {{ com Macro for combined \texttt{do} and \texttt{with}. }}

t :: 'trace_' ::= {{ com Traces. }}
 | t1 , t2 :: :: seq {{ com Sequence subtraces $[[t1]]$ and $[[t2]]$. }}
 | #empty :: :: empty {{ com Identity trace for sequencing. }}
 | p :: :: edgePointer {{ com Action recorded as an (outgoing) edge pointer. }}
 | { t }_out :: M :: labelUp {{ tex \underbrace{[[t]]}_{\text{\makecell[c]{output\\[-2mm] trace} } } }}

H :: 'traceHead_' ::= {{ com Nested trace heads. }}
 | force s :: :: force
 | do @ s with e :: :: doAtWith
 | do @ s :: :: doAt
 | with e :: :: with

G :: 'graph_' ::= {{ com Graphs. }}
 | #empty :: :: empty {{ com Empty graph. }}
 | p : NodeData :: :: node {{ com Graph node. }}
 | p : EdgeData :: :: arrow {{ com Graph edge. }}
 | G1 , G2 :: :: union {{ com Graph union (disjoint). }} 
 | { G }_out :: M :: labelUp {{ tex \underbrace{[[G]]}_{\text{output graph} } }}

p, q, r :: 'pointer_' ::= {{ com Pointers. }}
 | node s :: :: node {{ com Node pointer. }}
 | edge s :: :: edge {{ com Edge pointer. }}

EdgeData :: 'edge_' ::= {{ com Edge data. }}
 | p A v b q :: :: arrow {{ com \makecell{Source $[[p]]$, target $[[q]]$, action $[[A]]$,\\ value $[[v]]$ and dirty bit $[[b]]$.} }}
                           {{ tex [[p]] \rightarrow^[[A]]_{([[v]], [[b]])} [[q]] }}

A :: 'action_' ::= {{ com Actions (Edge arrow heads). }}
 | force  :: :: force {{ com Force action. }}
 | get :: :: get {{ com Get action. }}
 | put :: :: put {{ com Put action. }}

b :: 'dirtyBit_' ::= {{ com Dirty bit. }}
 | clean :: :: clean {{ com Clean. }}
 | dirty :: :: dirty {{ com Dirty. }}

NodeData :: 'node_' ::= {{ com Node data. }}
 | v :: :: refCell {{ com Reference cell. }}
 | ( path , e , - , - ) :: :: thunkUneval {{ com Thunk, unevaluated. }} {{ tex ([[path]], [[e]], \boxed{\tiny?}, \boxed{\tiny?}) }}
 | ( path , e , t , v ) :: :: thunkEvaled {{ com Thunk, evaluated. }}
 | ( path , e , _ , _ ) :: M :: thunkPattern

s :: 'sym_' ::= {{ com Symbols. }}
 | s1 - s2 :: :: minus {{ com Dash binary connective. }} {{ tex [[s1]]\texttt{-}[[s2]] }}
 | s1 . s2 :: :: dot {{ com Dot binary connective. }} {{ tex [[s1]]\texttt{.}[[s2]] }}
 | #elipses ::  :: dots {{ com Any identifier or number literal as a symbol. }}

terminals :: 'terminals_' ::=
| == :: :: equiv {{ tex \equiv }}
| /= :: :: noteq {{ tex  \neq }}
| forall :: :: forall {{ tex \forall }}
| exists :: :: exists {{ tex \exists }}
| %% :: :: apart {{ tex \otriangleup }}
| \ :: :: lambda {{ tex \lambda }}
| -> :: :: rightarrow {{ tex \texttt{->} }}
| => :: :: thickrightarrow {{ tex \texttt{=>} }}
| := :: :: defineOrAssign {{ tex \mathrel{\texttt:\texttt=} }}
| * :: :: cdot {{ tex \texttt{*} }}
| ^* :: :: stepStar {{ tex \texttt{\^{}*} }}
| +* :: :: plusStar {{ tex \texttt{+*} }}
| & :: :: amp {{ tex \texttt{\&} }}
| $ :: :: dollar {{ tex \texttt{\$} }}
| ! :: :: bang {{ tex \texttt{!} }}
| @ :: :: at {{ tex \texttt{@} }}
| >> :: :: mapOp {{ tex \texttt{>>} }}
| % :: :: projectOp {{ tex \texttt{\%} }}
| ~ :: :: tilde {{ tex \texttt{\textasciitilde} }} {{ com Text ascii tilde. }}
| |- :: :: vdash {{ tex \vdash }}
| ;; :: :: dsemi {{ tex {~|~} }}
| ~> :: :: leadsto {{ tex \leadsto }}
| --> :: :: lra {{ tex \longrightarrow }}
| !! :: :: downarrow {{ tex \Downarrow }}
| #elipses :: :: eplises {{ tex \cdots }}
| #empty :: :: empty {{ tex \epsilon }}



defns J :: '' ::=

defn
G |- p isClean :: :: clean :: 'clean_'
{{ com Pointer $[[p]]$ is clean in graph $[[G]]$. }}
by

defn
G |- s isFresh :: :: fresh :: 'fresh_'
{{ com Symbol $[[s]]$ is fresh in graph $[[G]]$. }}
by

defn
G |- s dirty :: :: dirty :: dirty_'
{{ com Node $[[s]]$ is dirty in graph $[[G]]$. }}
by

defn
e !! v :: :: pureEval :: 'pureEval_'
{{ com Pure evaluation. }}
by

% to do
% -------
% clean(G, p) = (G', v)
% dirtyInconsis(G, p, v) = G'
% dirtyAllInto(G, p) = G'

defn
Clean G ; p !! G' ; v
:: :: Clean :: 'Clean_'
{{ com Cleaning. }}
by

defn
DirtyAffected G ; p ; v !! G'
:: :: DirtyAffected :: 'DirtyAffected_'
{{ com Dirty all affected edges. }}
by

defn
DirtyForces G ; p !! G'
:: :: DirtyForces :: 'DirtyForces_'
{{ com Dirty all force edges. }}
by

defn
G1 ; p ; path |- e !! G2 ; t ; v ::  :: eval :: 'eval_'
{{ com Evaluation. }}
{{ tex [[G1]] \vdash_{[[p]]}^{[[path]]} [[e]] \Downarrow [[G2]] ; [[t]] ; [[v]] }}
by

------------------------------- :: val
G ; p ; path |- v !! G ; #empty ; v

G1 ; p ; path |- e1 !! G2; t1; v1
G2 ; p ; path |- [v1/x]e2 !! G3; t2; v2
----------------------------------------------------- :: let
G1 ; p ; path |- let x = e1 in e2 !! G3; t1,t2; v2

G1 ; p ; path |- e1 !! G2; t1; \x.e3
G2 ; p ; path |- e2 !! G3; t2; v2
G3 ; p ; path |- [v2/x]e3 !! G4; t3; v3
--------------------------------------------- :: app
G1 ; p ; path |- e1 (e2) !! G4; t1,t2,t3; v3

G1 ; p ; path |- e1 !! G2; t1; sym s1
G2 ; p ; path |- e2 !! G3; t2; sym s2
--------------------------------------------------- :: minus
G1 ; p ; path |- e1 - e2 !! G3; t1, t2; sym s1-s2

G1 ; p ; path |- e1 !! G2; t1; sym s1
G2 ; p ; path |- e2 !! G3; t2; sym s2
--------------------------------------------------- :: dot
G1 ; p ; path |- e1 . e2 !! G3; t1,t2; sym s1 . s2


G1 ; p ; path |- e1 !! G2 ; t1 ; sym s1
path ( sym s1 ) !! ptr q
G2 ; p ; path |- e2 !! G3 ; t2 ; v
v /= thunk { e3 }
% dirtyDepsOf(s)
G3 |- s2 isFresh
------------------------------------------------------------------------------------------------------------------- :: putRef
G1 ; p ; path |- @ e1 := e2 !! { G3, q : v, edge s2 : p put v clean q }_out ; { t1,t2, edge s2 }_out ; ptr q


G1 ; p ; path |- e1 !! G2 ; t1; sym s1
path ( sym s1 ) !! ptr q
G2 ; p ; path |- e2 !! G3 ; t2; v
v = thunk { e3 }
% dirtyDepsOf(s)
G2 |- s2 isFresh
------------------------------------------------------------------------------------------------------------- :: putThunk
G1 ; p ; path |- @ e1 := e2 !! { G3, q: (path, e3, -, -), edge s2 : p put v clean q }_out ; { t1,t2, edge s2 }_out ; ptr q


G1 ; p ; path |- e1 !! G2; t1; ptr q
G2(q) = v
G2 |- s isFresh
------------------------------------------------------------------------------------ :: getRef
G1 ; p ; path |- @ e1 !! { G2, edge s : p get v clean q }_out; {t1, edge s}_out; v


G1 ; p ; path |- e1 !! G2; t1 ; ptr q
G2(q) = (path', e2, _, _)
G2 |- s' isFresh
------------------------------------------------------------------------------------------- :: getThunk
G1 ; p ; path |- @ e1 !! G2, edge s' : p get thunk {e2} clean q; t1, edge s'; thunk {e2}


G1 ; p ; path |- e !! G2 ; t1; thunk { e1 }
G2 ; p ; path |- e1 !! G3 ; t2; v
----------------------------------------------- :: forcePure
G1 ; p ; path |- force e !! G2 ; t1,t2 ; v


G1 ; p ; path |- e !! G2 ; t1; ptr q
G2(q) = (path', e1, t2, v)
G2 |- q isClean
G2 |- s isFresh
--------------------------------------------------------------------------------- :: forceClean
G1 ; p ; path |- force e !! { G2, edge s : p force v clean q }_out ; { edge s }_out ; v


G1 ; p ; path |- e !! G2 ; t1 ; ptr q
G1(q) = (path', e1, -, -)
G2 ; q ; path' |- e1 !! G3 ; t2 ; v
G3 |- s isFresh
------------------------------------------------------------------------------------------------------ :: forceEval
G1 ; p ; path |- force e !! G3, q : (path', e1, t2, v), edge s : p force v clean q ; t1, edge s ; v


G1 ; p ; path |- e !! G2 ; ptr node s1 ; t1
G2(s1) = (path', e1, v, t2)
G2 |- s1 dirty
G2 ; s1 ; path' |- e1 !! G3 ; v' ; t2'
G3 |- s' isFresh
-------------------------------------------------------------------------------------------------------------- :: forceDirty
G1 ; p ; path |- force e !! G3, s1 : (path', e1, v', t2'), arrow s' s force v' clean s1 ; v' ; t1, force s1 { t2' }


G1 ; p ; \x.path(path'(x)) |- e1 !! G2 ; t ; v
------------------------------------------------------- :: with
G1 ; p ; path |- with path' { e1 } !! G2 ; t ; v



%% G1 ; p ; path |- e1 !! G2 ; sym s1 ; t1
%% path ( sym s1 ) !! sym s2
%% G2, s2:(path, e2, -, -); p ;  path |- force (ptr node s2) !! G3 ; v ; force s2 { t2 }
%% ----------------------------------------------------------------------------- :: doAt
%% G1 ; p ; path |- do @ e1 { e2 } !! G3; v; t1, do @s2 { t2 }


%% G1 ; p ; path |- e1 !! G2 ; sym s1 ; t1
%% path(sym s1) !! sym s2
%% G2, s2:(\x.path(path'(x)), e2, -, -); p ;  path |- force (ptr node s2) !! G3 ; v ; force s2 { t2 }
%% ---------------------------------------------------------------------------------------- :: doAtWith
%% G1 ; p ; path |- do @ e1 with path' { e2 } !! G3; v; t1, do @s2 with path' { t2 }
