embed {{ tex-preamble
\usepackage{charter}
\usepackage{euler}
\usepackage{inconsolata}
\usepackage{mathabx} % for otriangleup
\usepackage{xcolor}
}}

metavar x , y , z ::=
{{ coq nat}} {{ coq-equality }}

grammar

formula :: 'formula_' ::=
 | judgement :: :: judgement
 | G ( s ) =  n :: :: graphGetNode
 | v1 = v2 :: :: equal
 | v1 /= v2 :: :: notEqual
 | G1 = G2 :: :: graphEqual

v :: 'v_' ::= {{ com Values. }}
 | \ x . e :: :: lambda {{ com Lambda. }}
 | x :: :: var {{ com Variable. }}
 | #elipses :: :: dots {{ com Other existing forms. }}
 | thunk { e } :: :: thunk {{ com Thunk. }}
 | sym s :: :: symbol {{ com Symbol. }}
 | addr s :: :: address {{ com Address. }}

e :: 'e_' ::= {{ com Expressions. }}
 | let x = e1 in e2 :: :: let {{ com Let sequencing. }}
 | e1 ( e2 ) :: :: apply {{ com Application. }}
 | e1 - e2 :: :: symbolDash {{ com Minus binop. }}
 | e1 . e2 :: :: symbolDot {{ com Dot binop. }}
 | [ v / x ] e :: M :: subst {{ com Substituion. }}
 | v :: :: value {{ com Value. }}
 | #elipses ::  :: dots {{ com Other existing forms. }}
 | @ e1 := e2 :: :: put {{ com Put value at symbol. }}
 | @ e1 :: :: get {{ com Get value at symbol. }}
 | force e :: :: force {{ com Force a thunk, or thunk address. }}
 | h { e3 } :: :: nest {{ com Nested subcomputation. }}
 | ( e ) :: M :: paren {{ com Paren. }}

h :: 'head_' ::= {{ com Nested expression heads. }}
 | do @ e1 with e2 :: :: doAtWith
 | do @ e :: :: doAt
 | with e :: :: with

t :: 'trace_' ::= {{ com Traces. }}
 | v :: :: value {{ com Final value $[[v]]$. }}
 | t1 , t2 :: :: seq {{ com Sequence subtraces $[[t1]]$ and $[[t2]]$. }}
 | #empty :: :: empty {{ com Identity trace for sequencing via \texttt{;}. }}
 | @ s := v :: :: put {{ com Put into $[[s]]$ value $[[v]]$. }}
 | @ s = v :: :: get {{ com Get from $[[s]]$ equals value $[[v]]$. }}
 | H { t } :: :: nest {{ com Nested subtrace, with head $[[H]]$. }}
 | { t }_out :: M :: labelUp {{ tex \underbrace{[[t]]}_{\text{output trace} } }}

H :: 'traceHead_' ::= {{ com Nested trace heads. }}
 | force s :: :: force
 | do @ s with e :: :: doAtWith
 | do @ s :: :: doAt
 | with e :: :: with

G :: 'graph_' ::= {{ com Graphs. }}
 | #empty :: :: empty {{ com Empty graph. }}
 | s : n :: :: node {{ com Graph node. }}
 | sa a :: :: arrow {{ com Graph edge (``arrow''). }} {{ tex [[sa]] : [[a]] }}
 | G1 , G2 :: :: union {{ com Graph union (disjoint). }}
 | { G }_out :: M :: labelUp {{ tex \underbrace{[[G]]}_{\text{output graph} } }}

a :: 'edge_' ::= {{ com Graph edges (``Arrows''). }}
 | s1 A v b s2 :: :: arrow {{ com Source $[[s1]]$, action $[[A]]$, value $[[v]]$, dirty bit $[[b]]$ and target $[[s2]]$. }}
                           {{ tex [[s1]] \rightarrow^[[A]]_{([[v]], [[b]])} [[s2]] }}

A :: 'action_' ::= {{ com Actions (``Arrow heads''). }}
 | force  :: :: force {{ com Force action. }}
 | get :: :: get {{ com Get action. }}
 | put :: :: put {{ com Put action. }}

b :: 'dirtyBit_' ::= {{ com Dirty bit. }}
 | clean :: :: clean {{ com Clean. }}
 | dirty :: :: dirty {{ com Dirty. }}

n :: 'node_' ::= {{ com Node payloads. }}
 | ( e0 , e , - , - ) :: :: thunkUneval {{ com Thunk, unevaluated. }} {{ tex ([[e0]], [[e]], \boxed{\tiny?}, \boxed{\tiny?}) }}
 | ( e0 , e , v , t ) :: :: thunkEvaled {{ com Thunk, evaluated. }}
 | ( e0 , e , _ , _ ) :: M :: thunkPattern
 | v :: :: refCell {{ com Reference cell. }}

s :: 'sym_' ::= {{ com Symbols. }}
 | s1 - s2 :: :: minus {{ com Dash binary connective. }} {{ tex [[s1]]\texttt{-}[[s2]] }}
 | s1 . s2 :: :: dot {{ com Dot binary connective. }} {{ tex [[s1]]\texttt{.}[[s2]] }}
 | #elipses ::  :: dots {{ com Any identifier or number literal as a symbol. }}

sa :: 'symarr_' ::= {{ com Symbols for arrows. }}
 | arrow s :: :: arrow {{ com Arrow symbol. }} {{ tex \vec{[[s]]} }}

terminals :: 'terminals_' ::=
| == :: :: equiv {{ tex \equiv }}
| /= :: :: noteq {{ tex  \neq }}
| forall :: :: forall {{ tex \forall }}
| exists :: :: exists {{ tex \exists }}
| %% :: :: apart {{ tex \otriangleup }}
| \ :: :: lambda {{ tex \lambda }}
| -> :: :: rightarrow {{ tex \texttt{->} }}
| => :: :: thickrightarrow {{ tex \texttt{=>} }}
| := :: :: defineOrAssign {{ tex \mathrel{\texttt:\texttt=} }}
| * :: :: cdot {{ tex \texttt{*} }}
| ^* :: :: stepStar {{ tex \texttt{\^{}*} }}
| +* :: :: plusStar {{ tex \texttt{+*} }}
| & :: :: amp {{ tex \texttt{\&} }}
| $ :: :: dollar {{ tex \texttt{\$} }}
| ! :: :: bang {{ tex \texttt{!} }}
| @ :: :: at {{ tex \texttt{@} }}
| >> :: :: mapOp {{ tex \texttt{>>} }}
| % :: :: projectOp {{ tex \texttt{\%} }}
| ~ :: :: tilde {{ tex \texttt{\textasciitilde} }} {{ com Text ascii tilde. }}
| |- :: :: vdash {{ tex \vdash }}
| ;; :: :: dsemi {{ tex {~|~} }}
| ~> :: :: leadsto {{ tex \leadsto }}
| --> :: :: lra {{ tex \longrightarrow }}
| !! :: :: downarrow {{ tex \Downarrow }}
| #elipses :: :: eplises {{ tex \cdots }}
| #empty :: :: empty {{ tex \epsilon }}



defns J :: '' ::=

defn
G |- s isClean :: :: clean :: 'clean_'
{{ com Node $[[s]]$ is clean in graph $[[G]]$. }}
by

defn
G |- s isFresh :: :: fresh :: 'fresh_'
{{ com Symbol $[[s]]$ is fresh in graph $[[G]]$. }}
by

defn
G |- s dirty :: :: dirty :: dirty_'
{{ com Node $[[s]]$ is dirty in graph $[[G]]$. }}
by

defn
e !! v :: :: pureEval :: 'pureEval_'
{{ com Pure evaluation. }}
by


defn
G1 ; s ; e0 |- e !! G2 ; v ; t ::  :: eval :: 'eval_'
{{ com Evaluation. }}
{{ tex [[G1]] \vdash^{[[s]]}_{[[e0]]} [[e]] \Downarrow [[G2]] ; [[v]] ; [[t]] }}
by

------------------------------- :: val
G ; s ; e0 |- v !! G ; v ; v

G1 ; s ; e0 |- e1 !! G2; v1; t1
G2 ; s ; e0 |- [v/x]e2 !! G3; v2; t2
----------------------------------------------------- :: let
G1 ; s ; e0 |- let x = e1 in e2 !! G3; v2; t1,t2

G1 ; s ; e0 |- e1 !! G2; \x.e3; t1
G2 ; s ; e0 |- e2 !! G3; v2; t2
G3 ; s ; e0 |- [v2/x]e3 !! G4; v3; t3
--------------------------------------------- :: app
G1 ; s ; e0 |- e1 (e2) !! G4; v3; t1,t2,t3

G1 ; s ; e0 |- e1 !! G2; sym s1; t1
G2 ; s ; e0 |- e2 !! G3; sym s2; t2
------------------------------------------------ :: minus
G1 ; s ; e0 |- e1 - e2 !! G3; sym s1-s2; t1,t2

G1 ; s ; e0 |- e1 !! G2; sym s1; t1
G2 ; s ; e0 |- e2 !! G3; sym s2; t2
------------------------------------------------ :: dot
G1 ; s ; e0 |- e1 . e2 !! G3; sym s1 . s2; t1,t2

G1 ; s ; e0 |- e1 !! G2 ; sym s1 ; t1
e0 ( sym s1 ) !! sym s2
G2 ; s ; e0 |- e2 !! G3 ; v ; t2
v /= thunk { e3 }
% dirtyDepsOf(s)
G3 |- s' isFresh
---------------------------------------------------------------------------------------- :: putRef
G1 ; s ; e0 |- @ e1 := e2 !! G3, s2: v, arrow s' s put v clean s2 ; addr s2 ; t1,t2, @s2 := v

G1 ; s ; e0 |- e1 !! G2 ; sym s1 ; t1
e0 ( sym s1 ) !! sym s2
G2 ; s ; e0 |- e2 !! G3 ; v ; t2
v = thunk { e3 }
% dirtyDepsOf(s)
G2 |- s' isFresh
--------------------------------------------------------------------------------------------------- :: putThunk
G1 ; s ; e0 |- @ e1 := e2 !! G3, s2: (e0, e3, -, -), arrow s' s put v clean s2 ; addr s2 ; t1,t2, @s2 := v

G1 ; s ; e0 |- e1 !! G2; sym s1 ; t1
G2(s1) = v
G2 |- s' isFresh
------------------------------------------------------------ :: getRef
G1 ; s ; e0 |- @ e1 !! G2, arrow s' s get v clean s1; v; t1, @s = v

G1 ; s ; e0 |- e1 !! G2; sym s1 ; t1
G2(s1) = (e0', e2, _, _)
G2 |- s' isFresh
-------------------------------------------------------------------------------------- :: getThunk
G1 ; s ; e0 |- @ e1 !! G2, arrow s' s get thunk {e2} clean s1; thunk {e2}; t1, @s = thunk {e2}

G1 ; s ; e0 |- e !! G2 ; thunk { e1 } ; t1
G2 ; s ; e0 |- e1 !! G3 ; v ; t2
----------------------------------------------- :: forcePure
G1 ; s ; e0 |- force e !! G2 ; v ; t1,t2

G1 ; s ; e0 |- e !! G2 ; addr s1 ; t1
G2(s1) = (e0', e1, v, t2)
G2 |- s1 isClean
G2 |- s' isFresh
------------------------------------------------------------------------------------------------------- :: forceClean
G1 ; s ; e0 |- force e !! { G2, arrow s' s force v clean s1 }_out ; v ; { t1, force s1 { t2 } }_out

G1 ; s ; e0 |- e !! G2 ; addr s1 ; t1
G1(s1) = (e0', e1, -, -)
G2 ; s1 ; e0' |- e1 !! G3 ; v ; t2
G3 |- s' isFresh
-------------------------------------------------------------------------------------------------------- :: forceEval
G1 ; s ; e0 |- force e !! G3, s1 : (e0', e1, v, t2), arrow s' s force v clean s1 ; v ; t1, force s1{ t2 }

G1 ; s ; e0 |- e !! G2 ; addr s1 ; t1
G2(s1) = (e0', e1, v, t2)
G2 |- s1 dirty
G2 ; s1 ; e0' |- e1 !! G3 ; v' ; t2'
G3 |- s' isFresh
-------------------------------------------------------------------------------------------------------------- :: forceDirty
G1 ; s ; e0 |- force e !! G3, s1 : (e0', e1, v', t2'), arrow s' s force v' clean s1 ; v' ; t1, force s1 { t2' }

G1 ; s ; \x.e0(e0'(x)) |- e1 !! G2 ; v ; t1 
-------------------------------------------------------------- :: with
G1 ; s ; e0 |- with e0' { e1 } !! G2 ; v ; with e0' { t1 }



%% G1 ; s ; e0 |- e1 !! G2 ; sym s1 ; t1
%% e0 ( sym s1 ) !! sym s2
%% G2, s2:(e0, e2, -, -); s ;  e0 |- force (addr s2) !! G3 ; v ; force s2 { t2 }
%% ----------------------------------------------------------------------------- :: doAt
%% G1 ; s ; e0 |- do @ e1 { e2 } !! G3; v; t1, do @s2 { t2 }


%% G1 ; s ; e0 |- e1 !! G2 ; sym s1 ; t1
%% e0(sym s1) !! sym s2
%% G2, s2:(\x.e0(e0'(x)), e2, -, -); s ;  e0 |- force (addr s2) !! G3 ; v ; force s2 { t2 }
%% ---------------------------------------------------------------------------------------- :: doAtWith
%% G1 ; s ; e0 |- do @ e1 with e0' { e2 } !! G3; v; t1, do @s2 with e0' { t2 }
