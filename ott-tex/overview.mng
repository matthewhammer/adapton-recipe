\documentclass[11pt]{article}
\usepackage{charter}
\usepackage{euler}
\usepackage{inconsolata}
\usepackage{xcolor}

\newcommand{\ottnt}[1]{\ensuremath{mathit{#1}}}
\newcommand{\ottmv}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\ottkw}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ottcom}[1]{{#1}}
\newcommand{\ottsym}[1]{{#1}}

\begin{document}

\title{Adapton, distilled and refined.}

\maketitle

\subsection*{Overview}

\paragraph{Variable names versus symbol names.}

Adapton distinguishes (ordinary) variables from what we call \emph{symbols}.

By \emph{variables}, we mean lexically-scoped names that obey mathematical expectations about substitution and $\alpha$-equivalence.  PL researchers use readily use tools to model these formally and mechanically.

Adapton symbols give structure to program-determined pointers in a global memory and cache system.

\paragraph{Meta variables for program variables}

\[ [[ x ]], [[ y ]], [[ z ]]\]

When using lexically-scoped variables that follow the usual principles
of substitution and alpha conversion, we use italics (as with $x, y,
z$, above).  Italics distinguish these meta variables from
\emph{symbols}, that do not follow ordinary lexical scoping or
substitution rules.

\paragraph{Symbols (are not variables).}

We give some example symbols, but see the Examples Document for a fuller discussion.
Notice that we use non-italic monospace font:

\[ [[ a ]]\]
\[ [[ b ]]\]
\[ [[ xSymbol ]]\]
\[ [[ a b c ]]\]

Sequences with balanced delimiters (paren, brace, bracket):

\[ [[ ( a b c ) ]]\]
\[ [[ a ( b { c } a ) ]]\]
\[ [[ a ( ( b ) ( ) [ c b ] ) ]]\]

With commas and other internal delimiters

\[ [[ a ( b , ,  b  , a ) ]]\]
\[ [[ a ( c ; { b } ; , a ) ]]\]
\[ [[ a ( ( , - - c , ) ( ) [ b | a b ( c a ) a ] ) ]]\]

We prefix symbol trees with \textbf{\$} to promote them into constant
terms.


\paragraph{Symbols (as trees)}

In Adapton, symbols serve several interconnected roles:

\begin{itemize}

\item
Symbols are first-class values.

\item
 Concretely, each symbol is generally a \emph{tree}, formed from
 binary connectives, perhaps enhanced with balanced delimiters and
 possibly other (simple) connective forms.

\item
Symbols organize and address global state, where programs do put and get operations.

%\item
%Symbol sets index types as type refinements,
%indicating what symbols and addresses their values contain.

\item
Collections of symbols have internal structure as familes of trees, and

\item
The collective design of symbolic structure by programmers fully determines
incremental caching and reuse semantics for their program's behavior.

\end{itemize}

Unlike lexically-bound variables, symbols play a role in naming
program effects, and are not meant to be ``meaningless'' or freely
alpha-converted into other symbols.

Because name relationships reflect a deliberate design with important
determinative qualities for cache performance, they should be carried
through the programming language system, to the extent this is
possible, not discarded.

Instead of alpha conversion, we consider a kind of ``namespace
substitution'' property that shows how to vary them without affecting
program semantics (beyond concrete name choices).


\[ [[ G' |- p : E' ]] \]


\end{document}
