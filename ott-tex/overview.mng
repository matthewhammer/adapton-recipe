\documentclass[11pt]{article}
\usepackage{charter}
\usepackage{euler}
\usepackage{inconsolata}
\usepackage{xcolor}

\newcommand{\ottnt}[1]{\ensuremath{mathit{#1}}}
\newcommand{\ottmv}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\ottkw}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ottcom}[1]{{#1}}
\newcommand{\ottsym}[1]{{#1}}

\begin{document}

\title{Adapton, distilled and refined.}

\maketitle

\subsection*{Overview}

\paragraph{Variable names versus symbol names.}

Adapton distinguishes (ordinary) variables from what we call \emph{symbols}.

By \emph{variables}, we mean lexically-scoped names that obey mathematical expectations about substitution and $\alpha$-equivalence.

Adapton variables may range over values that include symbols.

Collectively, symbol choices give structure to program-determined pointers in a global memory and incremental cache system.

In choosing the patterns that symbols use in their programs,
programmers exercise control over incremental reuse when the program
responds to incremental changes.

\paragraph{Symbols as trees.}

In Adapton, symbols serve several interconnected roles:

\begin{itemize}

\item
Symbols are first-class values.

\item
 Concretely, each symbol is generally a \emph{tree}, formed from
 binary connectives, perhaps enhanced with balanced delimiters and
 possibly other (simple) connective forms.

\item
Symbols organize and address global state, where programs do put and get operations.

%\item
%Symbol sets index types as type refinements,
%indicating what symbols and addresses their values contain.

\item
Collections of symbols have internal structure as familes of trees, and

\item
The collective design of symbolic structure by programmers fully determines
incremental caching and reuse semantics for their program's behavior.

\end{itemize}


\paragraph{Support for hash consing.}

Symbols give an alternative to automatic hash-consing, where the cache
addresses are determined by content, not by separate program choices.

The symbolic cache actually subsumes hash consing: By choosing the
symbolic name to coincide with the data itself (or its hash), the
symbolic store implements hash consing as a mode of use.


\paragraph{Symbol substitution (lack of $\alpha$-equivalence).}

The structural relationships of symbols in a program reflect a
deliberate design with important determinative qualities for cache
performance.

Unlike lexically-bound variables, symbols play a role in naming
program effects, and are not meant to be ``meaningless'' or freely
alpha-converted into other symbols.

Instead of alpha conversion, we consider a kind of ``namespace
substitution'' property that shows how to vary them without affecting
the incremental semantics (the cache's patterns of reuse, based on
symbolic choices).


\end{document}
